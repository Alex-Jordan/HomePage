On Runestone for Intro Courses
==============================

By `Jackie Cohen <https://jczetta.github.io/>`_

I began using Runestone as a computer programming course instructor in 2014. In the ensuing five years, I've taught a variety of programming courses, with a variety of levels and audiences, which used a variety of Runestone books and features -- more and more, as more have been developed -- and I have worked on some Runestone features myself.

This means that I've explored Runestone in a variety of ways, and for a variety of reasons. Many Runestone Interactive materials, and features available in the platform, have proven particularly valuable to me in one type of use case: using a Runestone textbook as the source material for an true introductory programming course, where the course is primarily made up of students who have *never* done any computer programming before.

This is the kind of use case I'll share some things about here: an example of which material(s) I've selected for intro courses, why I think Runestone is a useful choice for intro programming courses, and particular ways that I've relied on a couple of Runestone features to help me achieve pedagogical goals in my class.

Of course, "an introductory programming course" can look like many different things, for many different reasons, and have many different audiences and structures, but here I am speaking generically from my experience being an instructor of college-level students who have never programmed before, enrolled in a class of between 50 - 250, as our course sizes vary from semester to semester!

(Note also that while I refer to a bunch of ideas about pedagogy and what students struggle with, below, what I'm talking about here are all anecdotal experiences of my own as an instructor -- there is a lot of great research about related things as well if you're looking for more detail on computer science, engineering, and programming education.)


So - Which Runestone Book(s)?
-----------------------------

The introductory courses I have usually taught over the past several years in my department are taught in the Python programming language. I've used a couple different versions of course materials over the years, but for the purposes of this explanation, I'll examine a case where I choose `Foundations of Python Programming <https://runestone.academy/runestone/static/fopp/index.html>`_ as the course textbook.

I've also used selections at times from other Runestone materials, which is a nice backup for a time that one book has, say, 98% of what I want.

Why Runestone?
--------------

A primary highlight of selecting a Runestone-based textbook as my course textbook is the stability it offers my class, on a few different axes, and this is why I've chosen to use it repeatedly.

First, and primary to my choice of Runestone for introductory classes, is the fact that using Runestone to learn computer programming material does *not* involve any installation or dealing with the varieties of operating systems and software, but it *does* require learning new vocabulary and practices for saving and running code.

I find that installation is a huge barrier for many introductory programming students. It can be difficult, time-consuming, and annoying. The difficulty or annoyance of installation of a programming language interpreter, a text editor, a command prompt software, or anything else, can feel like proof that a student new to these ideas "doesn't belong here [in this class]".

Students who have never done any computer programming before, especially students who do not have a lot of experience with software tools or other types of computing, often struggle (as many computer-types do for a long time into our careers, really!) with the difference between a problem that requires struggle and creative problem-solving, and a problem that is not truly creative or "computationally challenging" and is rather caused by an error you can't control, or by forgetting to click a single button at the start of the installation process. And for large courses without a large staff of a TAs/et cetera, helping students complete installations with a ton of different systems and versions thereof can also be a huge pain, and not a great note on which to start a class -- plus it's difficult to balance this fact with the desire to start writing code and seeing things *happen* on your screen rigt away. Using a Runestone textbook solves these problems, and allows students to focus both on concepts AND upon the joy of seeing code "work" and even pass tests -- on the in the very first week of class.

Secondly, everything is in one place, rather than having a plethora of blog posts, links, a textbook, code files... all from Day 1. While I do integrate non-Runestone resources into many such courses, the Runestone textbook is always "home" for students, who often express (in my experience) that they feel overwhelmed by having a lot of new material in programming as well as a lot of new resources to use.

Using a Runestone textbook also allows me to integrate graded work of various types with un-graded work, helping me to emphasize during class that learning to program usually requires a lot of *practice*. If such and such thing is required/graded, but there's also A, B, and C helpful conceptual activities we will discuss in lecture next week... isn't it useful that they're just right there, too? A simplification, of course, but something I've valued especially when students in class don't have a lot of experience learning a *programming language* and are still adapting their own learning and practice expectations for the course. What they need at first is all there on one website.

(In some courses I've moved "off" Runestone in a second half of the course, e.g. to using files and command prompts, but the Runestone experience they have is something they can continue to rely on and can use for practice, and remains a way of gaining new information about syntax and concepts since it is still our course textbook.)

What's in Runestone?
--------------------

With these ideas in mind, there are a few Runestone features that I've relied on heavily during introductory classes like those I describe.

One is, of course, the `ActiveCode <https://runestone.academy/runestone/static/overview/overview.html#activecode-examples>`_ feature -- we can write a program on the first day of class, and begin to understand the process of writing, thinking about, and running code, and how to *see* and `check the results <https://runestone.academy/runestone/static/overview/overview.html#hidden-unit-tests-with-graphical-status>`_ of code that's been run. The `CodeLens <https://runestone.academy/runestone/static/overview/overview.html#codelens-predictions>`_ tool is a huge help with this, because explanations that I previously needed to include in additional resources or slides are built right into readings, so class time can focus on in-depth exploration that supports understanding even more.

Another is the `ShowEval Trace <https://runestone.academy/runestone/static/overview/overview.html#showeval-trace-mode>`_ and `ShowEval Replace <https://runestone.academy/runestone/static/overview/overview.html#showeval-replace-mode>`_ modes -- as we begin writing code, I like to ensure I have a focus on understanding complex expressions and *debugging*, and this feature is a nice interactive way to focus specifically on evaluation of complex expressions without generating them correctly prior to evaluating them.

The availability of the `Parsons Problems <https://runestone.academy/runestone/static/overview/overview.html#parsons-problems>`_ for a `variety of reasons <https://dl.acm.org/citation.cfm?id=3141895>`_ has proven valuable in my introductory courses -- one way I like to use these features in class is that after I've, for example, assigned these as part of readings before class, I can return to them during a lecture so we can analyze together what ways of solving them are productive (rather than simple trial-and-error, for example), and we can really dig into useful ways of practicing and learning programming so students can experience them with me. I've used Parsons Problems both with code, like in `the code based example at the bottom of this page <https://runestone.academy/runestone/static/fopp/SimplePythonData/Exercises.html>`_, and with non-code words, like in `the non-code example at the bottom of this page <https://runestone.academy/runestone/static/fopp/SimplePythonData/StatementsandExpressions.html>`_, and find a mix of the two helpful.

And finally, because I can assign reading assignments as part of the course, and I can choose a book with a structure I want (e.g. the way FOPP has chapters followed by exercises and sets of "chapter assessment" exercises) I can take advantage of the above to include all of those features (`and others <https://runestone.academy/runestone/static/overview/overview.html#id3>`_) in assignments/course work/student lab time/office hours. Students know that they will need to interact with these interactive features during the out of class time they spend reading, and we come back to the online course "home" to review and explore new concepts during class time.

When it comes time to introduce native programming on one's own computer in the introductory courses that I teach, there's a place to return to for conceptual things (the online Runestone textbook!), so it allows me in-class time to focus on identifying, and then solving, those problems that *do* come from 'simply' forgetting to click one button or remembering the type of your operating system -- since identifying that kind of struggle/problem is also a very useful skill to identify and develop while students begin learning programming.


---





.. author:: Jackie Cohen
.. categories:: In Practice, How-To
.. tags:: none
.. comments::
